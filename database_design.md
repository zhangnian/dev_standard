# 数据库设计规范

### 基础规范

- **必须使用InnoDB存储引擎（5.6版本后的默认存储引擎）**

  > 解读：支持事务、行级锁、高并发下性能更好、CPU及内存缓存页优化使得资源利用率更高、更好的恢复性

- **新库默认使用utf8mb4字符集**

  > 解读：utf8mb4是utf8的超集，emoji表情以及部分不常见汉字在utf8下会表现为乱码，故需要升级utf8mb4。默认使用这个字符集的原因是：“标准，万国码，无需转码，无乱码风险”，但是并不“节省空间”。

- **数据表、数据字段必须加入中文注释**

  > CREATE TABLE建表时使用comment从句添加注释
  >
  > 从一开始维护好数据字典

- **禁止存储大文件或者图片**

  > 解读：大文件和图片存储在分布式文件系统或CDN上，数据库里存URI即可。




### 命名规范

- **所有数据库对象的命名使用单数小写字母，并使用下划线进行分割**

- **所有数据库对象的命名不允许使用MySQL关键字**

  > MySQL 5.7的所有关键字：https://dev.mysql.com/doc/refman/5.7/en/keywords.html

- **数据库对象的命名要做到见名知意，最好不要超过32个字符**

- **临时库、临时表的命名使用tmp作为前缀，当前日期作为后缀**

- **备份库、备份表的命名使用bak作为前缀，当前日期作为后缀**


- **只允许使用内网域名，而不是ip连接数据库**

  > 解读：不只是数据库，缓存(memcache、redis)的连接，服务(service)的连接都必须使用内网域名，便于机器迁移/平滑升级/运维管理

- **线上环境、开发环境、测试环境数据库内网域名遵循命名规范**

- **库名、表名、字段名使用小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用**

  > 表名使用单数形式，比如用户表为user，而非users，具体原因请参考：https://stackoverflow.com/questions/338156/table-naming-dilemma-singular-vs-plural-names




### 表设计规范

- **单表数据量大小（行数）控制在500w行内（经验值）**

  >通过定期归档或分库分表的方案控制单表的数据量，分表的键有：UserID、Date、Area等


- **单库表数目控制在300以内**

- **单表列数目控制在20 ~ 50**


  > MySQL限制单表最多只能有4096列
  >
  > 通过对表进行垂直拆分，将关联性较强的列放在同一个表中以控制表的列数，比如订单表、订单详情表

- **表必须有主键，例如自增主键**

  > 解读：
  >
  > 1）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用；
  >
  > 2）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率；
  >
  > 3）无主键的表删除，在row模式的主从架构，会导致备库夯住；

- **禁止使用存储过程、视图、触发器、Event**

- **禁止使用外键，如果有外键完整性约束，需要应用程序控制**

  > 外键会影响主表和子表的写操作，从而降低写入性能

- **禁止大表使用JOIN查询，禁止大表使用子查询**

  > 解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算上移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧！

- **使用整数存储货币**

  > 使用“分”作为单位，尽量不用除法（会丢失精度，导致对账出现问题），外币交易的支付金额精确到该币种的最小单位

- **少使用TEXT、BLOB类型，若实在要使用，将TEXT、BLOB字段用单独的表存储**

  > 会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能

- **禁止在表中建立预留字段**

  > 预留字段做不到见名知意
  >
  > 无法提前确定预留字段的类型

- **用好三类数值类型**

  > （1）TINYINT（1 Byte）、SMALLINT（2 Byte）、MEDIUMINT（3 Byte）、INT（4 Byte）、
  >
  > BIGINT（8 Byte）
  >
  > （2）FLOAT（4 Byte）、DOUBLE（8 Byte）
  >
  > （3）DECIMAL
  >
  > 比如，用无符号INT存储IP，而非CHAR(15)



### 字段设计规范

- **优先选择符合存储需要的最小的数据类型**

  > 1、将字符串形式的IP地址转化为无符号4字节整型数值存储
  >
  > INET_ATON('192.168.1.100') —> 3232235876
  >
  > INET_NTOA(3232235876) —> '192.168.1.100'
  >
  > 2、对于非负整型采用无符号整型进行存储
  >
  > 3、使用TIMESTAMP或DATETIME存储日期时间

- **必须把字段定义为NOT NULL并且提供默认值**

- **必须使用varchar(20)存储手机号**

  > 解读：
  >
  > 1）涉及到区号或者国家代号，可能出现+-()；
  >
  > 2）varchar可以支持模糊查询，例如：like "138%"

- **禁止使用ENUM，可使用TINYINT代替**

  > 解读：
  >
  > 1）增加新的ENUM值要做DDL操作
  >
  > 2）ENUM的内部实际存储就是整数

- **注意，VARCHAR(N)中的N代表的是字符数，而不是字节数**



### 索引设计规范

- **限制每张表上索引的数量，单表索引建议控制在5个以内**

- **单索引字段数不允许超过5个**

- **禁止在更新十分频繁、区分度不高的属性上建立索引**

  > 解读：
  >
  > 1）更新会更新B+树，更新频繁的字段建立索引会大大降低数据库性能；
  >
  > 2）"性别"这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似；

- **建立组合索引，必须把区分度高的字段放在前面**

- **每个Innodb表必须有一个主键**


  > 哪些字段不适合作为主键：
  >
  > 1、更新频繁的列
  >
  > 2、uuid、md5、字符串，因为无法保证递增性
  >
  > 建设使用自增ID列作为主键

- **常见索引字段建议**

  > 1、SELECT、UPDATE、DELETE语句的WHERE从句中的字段
  >
  > 2、包含着ORDER BY、GROUP BY、DISTINCT中的字段
  >
  > 3、多表JOIN的关联列（一般是主键ID）

- **避免建立冗余索引和重复索引**

  > 冗余索引：primary key(id)、index(id)、unique index(id)
  >
  > 重复索引：index(a, b, c)、index(a, b)、inde(a)

- **不在索引列做数学运算或函数运算，会无法使用索引导致全表扫描**

  

### SQL使用规范

- **禁止使用SELECT \*，只获取必要的字段**

  > 解读：
  >
  > 1）读取不需要的列会增加CPU、IO、NET消耗；
  >
  > 2）不能有效的利用覆盖索引；
  >
  > 3）使用SELECT *容易在增加或者删除字段后出现程序BUG；

- **禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性**

  > 解读：容易在增加或者删除字段后出现程序BUG

- **禁止使用属性隐式转换**

  > 解读：
  >
  > 假如有SQL语句：
  >
  > ```sql
  > SELECT uid FROM t_user WHERE phone=13812345678
  > ```
  >
  > 其中phone字段类型为varchar(20)，由于SQL语句带入的是整形，故会导致全表扫描，而不能命中phone索引。

- **禁止在WHERE条件的属性上使用函数或者表达式**

  > 解读：
  >
  > ```sql
  > SELECT uid FROM t_user WHERE from_unixtime(day)>='2017-02-15' 
  > ```
  >
  > 会导致全表扫描，正确的写法是：
  >
  > ```sql
  > SELECT uid FROM t_user WHERE day>= unix_timestamp('2017-02-15 00:00:00')
  > ```

- **禁止使用负向查询NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等，以及%开头的模糊查询，会导致全表扫描**

  > 解读：
  >
  > 一般来说，WHERE过滤条件不会只带这么一个“负向查询条件”，还会有其他过滤条件，举个例子：查询某个用户已完成订单之外的订单：
  >
  > ```sql
  > SELECT oid FROM t_order WHERE uid=123 AND status != 1
  > ```
  >
  > 订单表5000w数据，但uid=123就会迅速的将数据量过滤到很少的级别(uid建立了索引)，此时再接上一个负向的查询条件就无所谓了，扫描的行数本身就会很少。
  >
  > 但如果要查询所有已完成订单之外的订单：
  >
  > ```sql
  > SELECT oid FROM t_order WHERE status != 1; 
  > ```
  >
  > 这就挂了，立马CPU100%，status索引会失效，负向查询导致全表扫描。

- **禁止大表使用JOIN查询，禁止大表使用子查询**

  > 解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能

- **应用程序必须捕获SQL异常，并有相应处理**

- **同一字段，将OR改为IN**

  > OR效率：O(n)
  >
  > IN效率：O(Log(n))
  >
  > 当n很大时，OR会慢很多，注意控制IN的个数，建议n小于200
  >
  > BAD：SELECT id, username FROM user WHERE phone = '1234' OR phone = '2345'
  >
  > GOOD：SELECT id, username FROM user WHERE phone IN ('1234', '2345')

- **不同字段，将OR改为UNION**

  > BAD：SELECT id, username FROM user WHERE phone = '1234' OR cell_phone = '2345'
  >
  > GOOD：
  >
  > SELECT id, username FROM user WHERE phone = '1234' 
  >
  > UNION 
  >
  > SELECT id, username FROM user WHERE cell_phone = '2345'

- **慎用COUNT(*)**

- **避免使用JOIN关联太多的表，最多不超过5个**

- **减少同数据库的交互次数**


  > 数据库更适合处理批量操作
  >
  > 合并多个相同的操作到一起

- **禁止使用ORDER BY RAND()进行随机排序**

- **禁止使用SQL做CPU密集型运算**

  > 复杂运算移到程序端CPU，比如：
  >
  > SELECT MD5("hello")

- **使用自增ID高效分页**

  > 传统分页：
  >
  > LIMIT偏移量越大则越慢
  >
  > SELECT * FROM goods LIMIT 100000, 10
  >
  > 推荐分页：
  >
  > SELECT * FROM goods WHERE id >= 100 LIMIT 10（每页10条）
  >
  > SELECT * FROM goods WHERE id >= 111 LIMIT 10（下一页）
  >

- **若无需对结果去重，用UNION ALL而非UNION**

  > UNION有去重开销

- 不要使用count(列名)或count(常量)来替代count(*)，count(*)是SQL 92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关

  > 说明： count( * ) 会统计值为 NULL 的行，而 count( 列名 ) 不会统计此列为 NULL 值的行。